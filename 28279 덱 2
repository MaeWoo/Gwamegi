#define _CRT_SECURE_NO_WARNINGS
#define MAX 2000001
#include <stdio.h>
#include <stdlib.h>
typedef struct Deque {
	int* data;
	int front, rear;
}Deque;
// 덱 초기화
void initDeque(Deque* q, int n) {
	q->data = (int*)malloc(sizeof(int) * n);
	q->front = q->rear = MAX/2;
}
// 공백 검사
int emptyDeque(Deque* q) {
	if (q->front == q->rear)
		return 1;
	else
		return 0;
}
// 덱의 앞에 추가
void insertFront(Deque* q, int price) {
	q->data[q->front] = price;
	q->front = q->front - 1;
}
// 덱의 뒤에 추가
void insertRear(Deque* q, int price) {
	q->rear = q->rear + 1;
	q->data[q->rear] = price;
}
// 맨 앞 빼고 출력
void deleteFront(Deque* q) {
	if (emptyDeque(q)) {
		printf("-1\n");
		return 0;
	}
	int tmp = q->data[q->front + 1];
	q->front = q->front + 1;
	printf("%d\n", tmp);
}
// 맨 뒤 빼고 출력
int deleteRear(Deque* q) {
	if (emptyDeque(q)) {
		printf("-1\n");
		return 0;
	}
	int tmp = q->data[q->rear];
	q->rear = q->rear - 1;
	printf("%d\n", tmp);
}
// 원소 갯수
void dequeCount(Deque* q) {
	printf("%d\n", q->rear - q->front);
}
// 덱이 비었으면 1
void dequeCheck(Deque* q) {
	if (emptyDeque(q)) {
		printf("1\n");
		return 0;
	}
	printf("0\n");
}
// 현재 front값
void dequeFront(Deque* q) {
	if (emptyDeque(q)) {
		printf("-1\n");
	}
	else
		printf("%d\n", q->data[q->front + 1]);
}
// 현재 rear값
void dequeRear(Deque* q) {
	if (emptyDeque(q)) {
		printf("-1\n");
	}
	else
		printf("%d\n", q->data[q->rear]);
}
int main() {
	int n, count, price;
	Deque q;
	scanf("%d", &n);
	initDeque(&q, MAX);
	for (int i = 0; i < n; i++) {
		scanf("%d", &count);
		if (count == 1) {
			scanf("%d", &price);
			insertFront(&q, price);
		}
		if (count == 2) {
			scanf("%d", &price);
			insertRear(&q, price);
		}
		if (count == 3) {
			deleteFront(&q);
		}
		if (count == 4) {
			deleteRear(&q);
		}
		if (count == 5) {
			dequeCount(&q);
		}
		if (count == 6) {
			dequeCheck(&q);
		}
		if (count == 7) {
			dequeFront(&q);
		}
		if (count == 8) {
			dequeRear(&q);
		}
	}
}
